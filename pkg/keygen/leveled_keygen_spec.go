package keygen

import (
	"fmt"
	"github.com/flipkart-incubator/diligent/pkg/charset"
	"github.com/flipkart-incubator/diligent/pkg/strgen"
	"log"
)

const (
	defaultDelim = "_"
)

// LeveledKeyGenSpec represents the specification for creating a Leveled Key Set
type LeveledKeyGenSpec struct {
	SubKeySets [][]string
	Delim      string
}

func NewRandomLeveledKeyGenSpec(numSubKeysPerLevel []int, subKeyLen int) *LeveledKeyGenSpec {
	numLevels := len(numSubKeysPerLevel)
	totalKeys := 1
	subKeySets := make([][]string, numLevels)
	strGen := strgen.NewStrGen(charset.AlphaUp)
	var err error

	// Validate number of levels
	if numLevels < 1 {
		panic(fmt.Sprintf("Number of levels must be at least 1. Got %d", numLevels))
	}

	// Validate subKeyLen
	if subKeyLen < 1 {
		panic(fmt.Sprintf("subKeyLen cannot be < 1. Got %d", subKeyLen))
	}

	// Loop over required number of keys at each level
	for level, numSubKeys := range numSubKeysPerLevel {
		// Validate number of keys in this level
		if numSubKeys < 1 {
			panic(fmt.Sprintf("Each level must have at least 1 key. At level %d got %d keys", level, numSubKeys))
		}

		// Update total number of keys
		totalKeys *= numSubKeys

		// Generate required number of unique random keys of the specified length for this level
		subKeySets[level], err = strGen.RandomStringsUnique(subKeyLen, numSubKeys)
		if err != nil {
			log.Fatal(err)
		}
	}

	// Compose the spec and return
	return &LeveledKeyGenSpec{
		SubKeySets: subKeySets,
		Delim:      defaultDelim,
	}
}

func NewLeveledKeyGenSpec(subKeySets [][]string) *LeveledKeyGenSpec {
	spec := &LeveledKeyGenSpec{
		SubKeySets: subKeySets,
		Delim:      defaultDelim,
	}

	if !spec.IsValid() {
		panic("Spec is not valid")
	}

	return spec
}

func (spec *LeveledKeyGenSpec) IsValid() bool {
	subKeySets := spec.SubKeySets
	numLevels := len(subKeySets)

	// Validate number of levels
	if numLevels < 1 {
		return false
	}

	// Take length of first subkey as the length of every subkey (and validate this below)
	subKeyLen := len(subKeySets[0][0])

	// Loop over set of keys in each level
	for _, subKeySet := range subKeySets {
		// Validate number of keys in this level
		n := len(subKeySet)
		if n < 1 {
			return false
		}

		// Validate all keys are of same length (compare with first subkey)
		for _, subKey := range subKeySet {
			if len(subKey) != subKeyLen {
				return false
			}
		}
	}
	return true
}

// NumLevels returns the number of levels in the LeveledKeyGen
func (spec *LeveledKeyGenSpec) NumLevels() int {
	if spec.SubKeySets == nil {
		return 0
	}
	return len(spec.SubKeySets)
}

// NumKeys returns the number of keys in the LeveledKeyGenSpec
func (spec *LeveledKeyGenSpec) NumKeys() int {
	if spec.SubKeySets == nil {
		return 0
	}
	rc := 1
	for _, ks := range spec.SubKeySets {
		rc *= len(ks)
	}
	return rc
}

// KeyLength returns the size of each key generated by the LeveledKeyGenSpec
func (spec *LeveledKeyGenSpec) KeyLength() int {
	if spec.SubKeySets == nil {
		return 0
	}
	return spec.LengthOfKeyPrefixAtLevel(spec.NumLevels() - 1)
}

// LengthOfKeyPrefixAtLevel returns the size of a key prefix with subkeys upto level n
// n varies in the range [0, spec.NumLevels()]
func (spec *LeveledKeyGenSpec) LengthOfKeyPrefixAtLevel(n int) int {
	if spec.SubKeySets == nil {
		return 0
	}
	if n < 0 || n >= spec.NumLevels() {
		panic(fmt.Sprintf("Invalid level: %d", n))
	}
	subKeyLen := len(spec.SubKeySets[0][0])
	// (subkeys * number of subkeys) + number of delimeters
	return (subKeyLen * (n + 1)) + n
}

